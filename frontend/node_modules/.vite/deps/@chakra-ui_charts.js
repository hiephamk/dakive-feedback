import {
  ResponsiveContainer
} from "./chunk-XKJ2OAVE.js";
import "./chunk-AFDACY62.js";
import {
  AbsoluteCenter,
  Box,
  ColorSwatch,
  Flex,
  FormatNumber,
  HStack,
  Separator,
  Show,
  Span,
  Stack,
  Text,
  defineStyle,
  useChakraContext,
  useLocaleContext
} from "./chunk-6VLXZJFH.js";
import {
  require_jsx_runtime
} from "./chunk-R535KVNV.js";
import "./chunk-2SUVAHUW.js";
import "./chunk-WLM5EP74.js";
import "./chunk-RJJ6DPM5.js";
import {
  require_react
} from "./chunk-PD3NECQZ.js";
import {
  __export,
  __toESM
} from "./chunk-DC5AMYBS.js";

// node_modules/@chakra-ui/charts/dist/esm/use-chart.js
var React = __toESM(require_react(), 1);
function useChart(props) {
  const { data, series = [], sort } = props;
  const id = React.useId();
  const [highlightedSeries, setHighlightedSeries] = React.useState(null);
  const isHighlightedSeries = (name) => highlightedSeries === name;
  const env = useLocaleContext();
  const sys = useChakraContext();
  const color = (key2) => sys.token(`colors.${key2}`, key2);
  const size = (key2) => sys.token(`sizes.${key2}`, key2);
  const spacing = (key2) => sys.token(`spacing.${key2}`, key2);
  const key = (prop) => prop ?? "value";
  const formatNumber = React.useCallback(
    (options) => {
      const formatter = new Intl.NumberFormat(env.locale, options);
      return (value) => formatter.format(value);
    },
    [env.locale]
  );
  const formatDate = React.useCallback(
    (options) => {
      return (value) => new Date(value).toLocaleDateString(env.locale, options);
    },
    [env.locale]
  );
  const getSeries = (item) => {
    var _a;
    if (!isObject(item)) return;
    const result = series.find((s) => {
      return s.name === item.name || s.name === getProp(item.payload, "name") || s.name === item.dataKey || s.name === getProp(item.payload, "dataKey");
    }) || { color: void 0 };
    result.color || (result.color = getProp(item.payload, "color"));
    result.label || (result.label = ((_a = result.name) == null ? void 0 : _a.toLocaleString()) || getProp(item.payload, "name"));
    return result;
  };
  const getTotal = (key2) => {
    return data.reduce((acc, d) => acc + Number(d[key2]), 0);
  };
  function getPayloadTotal(payload) {
    return payload == null ? void 0 : payload.reduce((acc, item) => {
      if (!item.value) return acc;
      const num = Number(item.value);
      const value = Number.isNaN(num) ? 0 : num;
      return acc + value;
    }, 0);
  }
  function getMin(key2) {
    return Math.min(...data.map((d) => Number(d[key2])));
  }
  function getMax(key2) {
    return Math.max(...data.map((d) => Number(d[key2])));
  }
  function getValuePercent(key2, value, domain) {
    const min = getMin(key2);
    const max = getMax(key2);
    if (domain) {
      const d = typeof domain === "function" ? domain({ min, max }) : domain;
      return (value - d[0]) / (d[1] - d[0]) * 100;
    }
    return value / getTotal(key2) * 100;
  }
  const sortedData = React.useMemo(() => {
    if (!sort) return data;
    return data.sort((a, b) => {
      const aValue = Number(a[sort.by]);
      const bValue = Number(b[sort.by]);
      return sort.direction === "desc" ? bValue - aValue : aValue - bValue;
    });
  }, [data, sort]);
  const getSeriesOpacity = (name, fallback = 0.2) => {
    if (name && highlightedSeries)
      return isHighlightedSeries(name) ? 1 : fallback;
  };
  const groupByImpl = (key2) => {
    return groupBy(data, key2);
  };
  return {
    id,
    key,
    // series
    data: sortedData,
    groupBy: groupByImpl,
    series,
    getSeries,
    // token functions
    color,
    size,
    spacing,
    // formatters
    formatNumber,
    formatDate,
    // state
    highlightedSeries,
    setHighlightedSeries,
    isHighlightedSeries,
    getSeriesOpacity,
    // value functions
    getTotal,
    getMin,
    getMax,
    getPayloadTotal,
    getValuePercent
  };
}
var isObject = (value) => typeof value === "object" && value !== null;
function getProp(item, key) {
  if (!key || !isObject(item)) return;
  return Reflect.get(item, key);
}
function groupBy(data, key) {
  const groups = /* @__PURE__ */ new Map();
  for (const item of data) {
    const value = item[key];
    const group = groups.get(value) || [];
    group.push(item);
    groups.set(value, group);
  }
  return Array.from(groups.values());
}

// node_modules/@chakra-ui/charts/dist/esm/chart/chart.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react3 = __toESM(require_react(), 1);
var ChartContext = (0, import_react3.createContext)({});
var useChartContext = () => (0, import_react3.useContext)(ChartContext);
var baseCss = defineStyle({
  width: "100%",
  [`& :where(${[
    ".recharts-cartesian-axis-tick-value",
    ".recharts-polar-angle-axis-tick-value",
    ".recharts-polar-radius-axis-tick-value",
    ".recharts-pie-label-text"
  ].join(", ")})`]: {
    fill: "fg.muted"
  },
  "& .recharts-cartesian-axis .recharts-label": {
    fill: "fg",
    fontWeight: "medium"
  },
  "& *": {
    outline: "none"
  },
  "& svg": {
    overflow: "visible"
  }
});
function ChartRoot(props) {
  const { children, css, chart, ...rest } = props;
  return (0, import_jsx_runtime.jsx)(ChartContext.Provider, { value: chart, children: (0, import_jsx_runtime.jsx)(
    Box,
    {
      aspectRatio: "landscape",
      textStyle: "xs",
      css: [baseCss, css],
      ...rest,
      children: (0, import_jsx_runtime.jsx)(ResponsiveContainer, { children })
    }
  ) });
}
function ChartGradient(props) {
  const chart = useChartContext();
  const { id, fillOpacity, stops } = props;
  return (0, import_jsx_runtime.jsx)("linearGradient", { id, x1: "0", y1: "0", x2: "0", y2: "1", children: stops.map((stop, index) => (0, import_jsx_runtime.jsx)(
    "stop",
    {
      offset: stop.offset,
      stopColor: chart.color(stop.color),
      stopOpacity: stop.opacity ?? fillOpacity
    },
    index
  )) });
}
var hAlignMap = {
  left: "flex-start",
  center: "center",
  right: "flex-end"
};
function ChartLegend(props) {
  const {
    payload,
    verticalAlign = "bottom",
    align = "center",
    title,
    orientation,
    nameKey,
    spacing = "3",
    interaction = "hover"
  } = props;
  const chart = useChartContext();
  const filteredPayload = payload == null ? void 0 : payload.filter(
    (item) => item.color !== "none" || item.type !== "none"
  );
  if (!(filteredPayload == null ? void 0 : filteredPayload.length)) return null;
  const spacingValue = typeof spacing === "number" ? `${spacing}px` : chart.spacing(spacing);
  return (0, import_jsx_runtime.jsxs)(
    Stack,
    {
      gap: "1.5",
      align: hAlignMap[align],
      pt: verticalAlign === "bottom" ? "3" : void 0,
      pb: verticalAlign === "top" ? "3" : void 0,
      children: [
        title && (0, import_jsx_runtime.jsx)(Text, { fontWeight: "medium", children: title }),
        (0, import_jsx_runtime.jsx)(
          Flex,
          {
            "data-orientation": orientation,
            gap: spacingValue,
            direction: { _horizontal: "row", _vertical: "column" },
            align: { _horizontal: "center", _vertical: "flex-start" },
            flexWrap: "wrap",
            children: filteredPayload.map((item, index) => {
              var _a;
              const config = chart.getSeries(item);
              const seriesName = (_a = config == null ? void 0 : config.name) == null ? void 0 : _a.toString();
              const name = getProp(item.payload, nameKey);
              return (0, import_jsx_runtime.jsxs)(
                HStack,
                {
                  gap: "1.5",
                  _icon: { boxSize: "3" },
                  style: {
                    opacity: chart.getSeriesOpacity(seriesName, 0.6)
                  },
                  onClick: () => {
                    if (interaction === "click" && seriesName) {
                      chart.setHighlightedSeries(
                        (prev) => prev === seriesName ? null : seriesName
                      );
                    }
                  },
                  onMouseEnter: () => {
                    if (interaction === "hover" && seriesName) {
                      chart.setHighlightedSeries(seriesName);
                    }
                  },
                  onMouseLeave: () => {
                    if (interaction === "hover" && seriesName) {
                      chart.setHighlightedSeries(null);
                    }
                  },
                  children: [
                    (config == null ? void 0 : config.icon) || (0, import_jsx_runtime.jsx)(ColorSwatch, { boxSize: "2", value: chart.color(config == null ? void 0 : config.color) }),
                    (0, import_jsx_runtime.jsx)(Span, { color: "fg.muted", children: name || (config == null ? void 0 : config.label) })
                  ]
                },
                index
              );
            })
          }
        )
      ]
    }
  );
}
function ChartTooltip(props) {
  const {
    payload: payloadProp,
    label,
    labelFormatter,
    hideLabel,
    hideIndicator,
    hideSeriesLabel,
    showTotal,
    fitContent,
    nameKey,
    formatter,
    render
  } = props;
  const chart = useChartContext();
  const payload = payloadProp == null ? void 0 : payloadProp.filter(
    (item) => item.color !== "none" || item.type !== "none"
  );
  const total = (0, import_react3.useMemo)(() => chart.getPayloadTotal(payload), [payload, chart]);
  const tooltipLabel = (0, import_react3.useMemo)(() => {
    const item = payload == null ? void 0 : payload[0];
    const itemLabel = `${getProp(item == null ? void 0 : item.payload, nameKey) || label || (item == null ? void 0 : item.dataKey) || "value"}`;
    return (labelFormatter == null ? void 0 : labelFormatter(itemLabel, payload ?? [])) ?? itemLabel;
  }, [payload, labelFormatter, label, nameKey]);
  if (!(payload == null ? void 0 : payload.length)) return null;
  return (0, import_jsx_runtime.jsxs)(
    Stack,
    {
      minW: fitContent ? void 0 : "8rem",
      gap: "1",
      rounded: "l2",
      bg: "bg.panel",
      px: "2.5",
      py: "1",
      textStyle: "xs",
      shadow: "md",
      children: [
        !hideLabel && (0, import_jsx_runtime.jsx)(Text, { fontWeight: "medium", children: tooltipLabel }),
        (0, import_jsx_runtime.jsx)(Box, { children: payload.map((item, index) => {
          var _a;
          const config = chart.getSeries(item);
          if (render) return render(item.payload);
          const formatted = formatter ? formatter(item.value, (config == null ? void 0 : config.label) || item.name) : (_a = item.value) == null ? void 0 : _a.toLocaleString();
          const [formattedValue, formattedName] = Array.isArray(formatted) ? formatted : [formatted, (config == null ? void 0 : config.label) || item.name];
          return (0, import_jsx_runtime.jsxs)(
            Flex,
            {
              gap: "1.5",
              wrap: "wrap",
              align: "center",
              _icon: { boxSize: "2.5" },
              children: [
                config == null ? void 0 : config.icon,
                (config == null ? void 0 : config.color) && !(config == null ? void 0 : config.icon) && !hideIndicator && (0, import_jsx_runtime.jsx)(
                  ColorSwatch,
                  {
                    rounded: "full",
                    boxSize: "2",
                    value: chart.color(config.color)
                  }
                ),
                (0, import_jsx_runtime.jsxs)(HStack, { justify: "space-between", flex: "1", children: [
                  !hideSeriesLabel && (0, import_jsx_runtime.jsx)(Span, { color: "fg.muted", children: formattedName }),
                  item.value && (0, import_jsx_runtime.jsx)(
                    Text,
                    {
                      fontFamily: "mono",
                      fontWeight: "medium",
                      fontVariantNumeric: "tabular-nums",
                      children: formattedValue
                    }
                  )
                ] })
              ]
            },
            index
          );
        }) }),
        showTotal && total != null && (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
          (0, import_jsx_runtime.jsx)(Separator, { mt: "1" }),
          (0, import_jsx_runtime.jsxs)(HStack, { gap: "1", justify: "space-between", pb: "1", children: [
            (0, import_jsx_runtime.jsx)(Span, { color: "fg.muted", children: "Total" }),
            (0, import_jsx_runtime.jsx)(
              Text,
              {
                fontFamily: "mono",
                fontWeight: "medium",
                fontVariantNumeric: "tabular-nums",
                children: (() => {
                  if (!formatter) return total.toLocaleString();
                  const formatted = formatter(total, "");
                  return Array.isArray(formatted) ? formatted[0] : formatted;
                })()
              }
            )
          ] })
        ] })
      ]
    }
  );
}
var isPolarViewBox = (viewBox) => "cx" in viewBox && "cy" in viewBox;
function ChartRadialText(props) {
  const { viewBox, title, description, gap = 24, fontSize = "2rem" } = props;
  const chart = useChartContext();
  if (!viewBox || !isPolarViewBox(viewBox)) return null;
  return (0, import_jsx_runtime.jsxs)(
    "text",
    {
      x: viewBox.cx,
      y: viewBox.cy,
      textAnchor: "middle",
      dominantBaseline: "middle",
      fill: chart.color("fg"),
      children: [
        (0, import_jsx_runtime.jsx)(
          "tspan",
          {
            x: viewBox.cx,
            y: viewBox.cy,
            style: { fontSize, fontWeight: 600 },
            children: title
          }
        ),
        (0, import_jsx_runtime.jsx)(
          "tspan",
          {
            x: viewBox.cx,
            y: (viewBox.cy || 0) + gap,
            style: { fill: chart.color("fg.muted") },
            children: description
          }
        )
      ]
    }
  );
}

// node_modules/@chakra-ui/charts/dist/esm/chart/namespace.js
var namespace_exports = {};
__export(namespace_exports, {
  Gradient: () => ChartGradient,
  Legend: () => ChartLegend,
  RadialText: () => ChartRadialText,
  Root: () => ChartRoot,
  Tooltip: () => ChartTooltip
});

// node_modules/@chakra-ui/charts/dist/esm/bar-list/bar-list.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var React2 = __toESM(require_react(), 1);
var ChartContext2 = React2.createContext({});
function BarListRoot(props) {
  const { chart, barSize = "10", children, ...rest } = props;
  return (0, import_jsx_runtime2.jsx)(Box, { ...rest, css: { "--bar-size": chart.size(barSize) }, children: (0, import_jsx_runtime2.jsx)(ChartContext2.Provider, { value: chart, children }) });
}
var BarListTitle = (props) => {
  return (0, import_jsx_runtime2.jsx)(HStack, { textStyle: "md", mb: "4", fontWeight: "medium", ...props });
};
var BarListContent = (props) => {
  return (0, import_jsx_runtime2.jsx)(Flex, { flexWrap: "nowrap", align: "flex-end", gap: "4", ...props });
};
function BarListTooltip(props) {
  const { payload, labelFormatter, ...rest } = props;
  const chart = React2.useContext(ChartContext2);
  const formatter = labelFormatter || chart.formatNumber({ style: "decimal" });
  if (!payload || chart.highlightedSeries !== payload.name) return null;
  return (0, import_jsx_runtime2.jsx)(
    AbsoluteCenter,
    {
      display: { base: "none", _groupHover: "block" },
      axis: "vertical",
      right: "2",
      zIndex: "1",
      textStyle: "xs",
      fontWeight: "medium",
      bg: "bg.panel",
      px: "1.5",
      py: "1",
      rounded: "l2",
      shadow: "xs",
      pointerEvents: "none",
      ...rest,
      children: formatter(payload.value)
    }
  );
}
function BarListBar(props) {
  const { label, tooltip, ...rest } = props;
  const chart = React2.useContext(ChartContext2);
  const getPercent = (value) => chart.getValuePercent("value", value, (e) => [0, e.max]);
  const series = chart.getSeries({ name: "name" });
  return (0, import_jsx_runtime2.jsx)(Stack, { flex: "1", ...rest, children: chart.data.map((item, index) => (0, import_jsx_runtime2.jsx)(
    HStack,
    {
      flex: 1,
      minH: "var(--bar-size)",
      w: "full",
      gap: "8",
      _hover: { bg: "bg.subtle" },
      onMouseMove: () => {
        if (!tooltip) return;
        if (chart.highlightedSeries === item.name) return;
        chart.setHighlightedSeries(item.name);
      },
      onMouseLeave: () => {
        if (!tooltip) return;
        chart.setHighlightedSeries(null);
      },
      children: (0, import_jsx_runtime2.jsxs)(Box, { pos: "relative", flex: "1", className: "group", children: [
        typeof tooltip === "function" ? tooltip({ payload: item }) : null,
        typeof tooltip === "boolean" && tooltip && (0, import_jsx_runtime2.jsx)(BarListTooltip, { payload: item }),
        (0, import_jsx_runtime2.jsx)(
          Box,
          {
            pos: "absolute",
            insetStart: "0",
            h: "full",
            bg: series == null ? void 0 : series.color,
            rounded: "l2",
            width: "var(--bar-width)",
            style: {
              ["--bar-width"]: `${getPercent(item.value)}%`
            }
          }
        ),
        (0, import_jsx_runtime2.jsx)(
          HStack,
          {
            flex: "1",
            justify: "flex-start",
            textStyle: "sm",
            pos: "relative",
            wordBreak: "break-all",
            w: "full",
            minH: "var(--bar-size)",
            px: "2.5",
            children: (0, import_jsx_runtime2.jsx)(Show, { when: label, fallback: item.name, children: label == null ? void 0 : label({ payload: item, index }) })
          }
        )
      ] })
    },
    item.name
  )) });
}
function BarListValue(props) {
  const { valueFormatter, ...rest } = props;
  const chart = React2.useContext(ChartContext2);
  const formatter = valueFormatter || chart.formatNumber({
    notation: "compact",
    maximumFractionDigits: 2
  });
  return (0, import_jsx_runtime2.jsx)(Stack, { ...rest, children: chart.data.map((item) => (0, import_jsx_runtime2.jsx)(
    HStack,
    {
      minH: "var(--bar-size)",
      justify: "flex-end",
      textStyle: "sm",
      fontWeight: "medium",
      children: formatter(item.value)
    },
    item.name
  )) });
}
function BarListLabel(props) {
  const { title, titleAlignment, children, ...rest } = props;
  return (0, import_jsx_runtime2.jsxs)(Stack, { ...rest, children: [
    (0, import_jsx_runtime2.jsx)(
      Text,
      {
        textStyle: "xs",
        fontWeight: "medium",
        color: "fg.muted",
        textAlign: titleAlignment,
        children: title
      }
    ),
    children
  ] });
}

// node_modules/@chakra-ui/charts/dist/esm/bar-list/namespace.js
var namespace_exports2 = {};
__export(namespace_exports2, {
  Bar: () => BarListBar,
  Content: () => BarListContent,
  Label: () => BarListLabel,
  Root: () => BarListRoot,
  Title: () => BarListTitle,
  Tooltip: () => BarListTooltip,
  Value: () => BarListValue
});

// node_modules/@chakra-ui/charts/dist/esm/bar-segment/bar-segment.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var React3 = __toESM(require_react(), 1);
var ChartContext3 = React3.createContext({});
function BarSegmentRoot(props) {
  const { chart, barSize = "10", children, ...rest } = props;
  return (0, import_jsx_runtime3.jsx)(Stack, { gap: "4", ...rest, css: { "--bar-size": chart.size(barSize) }, children: (0, import_jsx_runtime3.jsx)(ChartContext3.Provider, { value: chart, children }) });
}
var BarSegmentContent = React3.forwardRef(
  function BarSegmentContent2(props, ref) {
    const chart = React3.useContext(ChartContext3);
    return (0, import_jsx_runtime3.jsx)(
      Stack,
      {
        w: "full",
        gap: "1",
        ref,
        onMouseLeave: () => chart.setHighlightedSeries(null),
        ...props
      }
    );
  }
);
function BarSegmentLabel(props) {
  const chart = React3.useContext(ChartContext3);
  const getPercent = (value) => chart.getValuePercent("value", value);
  return (0, import_jsx_runtime3.jsx)(HStack, { ...props, children: chart.data.map((item) => (0, import_jsx_runtime3.jsx)(
    HStack,
    {
      flexShrink: "0",
      textStyle: "sm",
      fontWeight: "medium",
      lineClamp: 1,
      style: {
        ["--bar-percent"]: `${getPercent(item.value)}%`
      },
      flex: "var(--bar-percent)",
      children: item.name
    },
    item.name
  )) });
}
function BarSegmentBar(props) {
  const { tooltip, children, ...rest } = props;
  const chart = React3.useContext(ChartContext3);
  const getPercent = (value) => chart.getValuePercent("value", value);
  return (0, import_jsx_runtime3.jsxs)(HStack, { pos: "relative", gap: "1", ...rest, children: [
    chart.data.map((item) => (0, import_jsx_runtime3.jsxs)(
      Box,
      {
        pos: "relative",
        flexShrink: "0",
        flex: "var(--bar-percent)",
        height: "var(--bar-size)",
        bg: item.color,
        rounded: "l1",
        onMouseMove: () => {
          if (!tooltip) return;
          chart.setHighlightedSeries(item.name);
        },
        style: {
          ["--bar-percent"]: `${getPercent(item.value)}%`
        },
        children: [
          typeof tooltip === "function" ? tooltip({ payload: item }) : null,
          typeof tooltip === "boolean" && tooltip && (0, import_jsx_runtime3.jsx)(BarSegmentTooltip, { payload: item })
        ]
      },
      item.name
    )),
    children
  ] });
}
function BarSegmentReference(props) {
  const { value, label, ...rest } = props;
  const chart = React3.useContext(ChartContext3);
  const getPercent = (value2) => chart.getValuePercent("value", value2);
  return (0, import_jsx_runtime3.jsx)(
    Box,
    {
      h: label ? "150%" : "100%",
      pos: "absolute",
      insetStart: `var(--bar-percent)`,
      bottom: "0",
      style: { ["--bar-percent"]: `${getPercent(value)}%` },
      ...rest,
      children: (0, import_jsx_runtime3.jsxs)(Flex, { gap: "2", h: "full", children: [
        (0, import_jsx_runtime3.jsx)(
          Span,
          {
            w: "2px",
            h: "100%",
            bg: "bg.inverted",
            outline: "2px solid {colors.bg}"
          }
        ),
        label && (0, import_jsx_runtime3.jsx)(Span, { fontWeight: "medium", textStyle: "xs", pos: "relative", top: "-4px", children: label })
      ] })
    }
  );
}
function BarSegmentValue(props) {
  const chart = React3.useContext(ChartContext3);
  const getPercent = (value) => chart.getValuePercent("value", value);
  return (0, import_jsx_runtime3.jsx)(HStack, { ...props, children: chart.data.map((item) => (0, import_jsx_runtime3.jsx)(
    HStack,
    {
      textStyle: "sm",
      fontWeight: "medium",
      flexShrink: "0",
      style: {
        ["--bar-percent"]: `${getPercent(item.value)}%`
      },
      flex: "var(--bar-percent)",
      children: (0, import_jsx_runtime3.jsx)(
        FormatNumber,
        {
          value: item.value,
          notation: "compact",
          maximumFractionDigits: 2
        }
      )
    },
    item.name
  )) });
}
function BarSegmentLegend(props) {
  const { showPercent, showValue, valueFormatter, ...rest } = props;
  const chart = React3.useContext(ChartContext3);
  const formatter = valueFormatter || chart.formatNumber({ maximumFractionDigits: 2 });
  return (0, import_jsx_runtime3.jsx)(HStack, { wrap: "wrap", gap: "4", textStyle: "sm", ...rest, children: chart.data.map((item) => (0, import_jsx_runtime3.jsxs)(HStack, { children: [
    (0, import_jsx_runtime3.jsx)(
      ColorSwatch,
      {
        value: chart.color(item.color),
        boxSize: "0.82em",
        rounded: "full"
      }
    ),
    (0, import_jsx_runtime3.jsxs)(HStack, { gap: "1.5", children: [
      (0, import_jsx_runtime3.jsx)(Text, { children: item.name }),
      showValue && (0, import_jsx_runtime3.jsx)(Span, { fontWeight: "medium", children: formatter(item.value) }),
      showPercent && (0, import_jsx_runtime3.jsxs)(Span, { color: "fg.muted", children: [
        chart.getValuePercent("value", item.value).toFixed(0),
        "%"
      ] })
    ] })
  ] }, item.name)) });
}
function BarSegmentTooltip(props) {
  const { payload, ...rest } = props;
  const chart = React3.useContext(ChartContext3);
  if (!payload || chart.highlightedSeries !== payload.name) return null;
  const formatter = chart.formatNumber({ maximumFractionDigits: 2 });
  return (0, import_jsx_runtime3.jsxs)(
    HStack,
    {
      pos: "absolute",
      top: "-4",
      right: "4",
      bg: "bg.panel",
      textStyle: "xs",
      zIndex: "1",
      px: "2.5",
      py: "1",
      gap: "1.5",
      rounded: "l2",
      shadow: "md",
      ...rest,
      children: [
        (0, import_jsx_runtime3.jsx)(
          ColorSwatch,
          {
            value: chart.color(payload.color),
            boxSize: "0.82em",
            rounded: "full"
          }
        ),
        (0, import_jsx_runtime3.jsx)(Span, { children: payload.name }),
        (0, import_jsx_runtime3.jsx)(Span, { fontFamily: "mono", fontWeight: "medium", children: formatter(payload.value) })
      ]
    }
  );
}

// node_modules/@chakra-ui/charts/dist/esm/bar-segment/namespace.js
var namespace_exports3 = {};
__export(namespace_exports3, {
  Bar: () => BarSegmentBar,
  Content: () => BarSegmentContent,
  Label: () => BarSegmentLabel,
  Legend: () => BarSegmentLegend,
  Reference: () => BarSegmentReference,
  Root: () => BarSegmentRoot,
  Tooltip: () => BarSegmentTooltip,
  Value: () => BarSegmentValue
});
export {
  namespace_exports2 as BarList,
  BarListBar,
  BarListContent,
  BarListLabel,
  BarListRoot,
  BarListTitle,
  BarListTooltip,
  BarListValue,
  namespace_exports3 as BarSegment,
  BarSegmentBar,
  BarSegmentContent,
  BarSegmentLabel,
  BarSegmentLegend,
  BarSegmentReference,
  BarSegmentRoot,
  BarSegmentValue,
  namespace_exports as Chart,
  ChartGradient,
  ChartLegend,
  ChartRadialText,
  ChartRoot,
  ChartTooltip,
  useChart
};
//# sourceMappingURL=@chakra-ui_charts.js.map
